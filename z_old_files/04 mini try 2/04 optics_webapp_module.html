<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Optics WebApp Module Demo</title>
  <style>
    body { margin: 0; overflow: hidden; background: #111; }
    #vignette {
      pointer-events: none;
      position: absolute; top: 0; left: 0;
      width: 100%; height: 100%;
      background: radial-gradient(circle at center, transparent 50%, rgba(0,0,0,0.7) 100%);
      z-index: 1;
    }
  </style>
  <!-- Anime.js for animations -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js"></script>
</head>
<body>
  <div id="vignette"></div>
  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.152.2/build/three.module.js';
    import { OrbitControls } from 'https://unpkg.com/three@0.152.2/examples/jsm/controls/OrbitControls.js';

    // ===== CONFIGURATION =====
    const CONFIG = {
      rotationSpeed: 0.1,        // spinnyMcSpin
      dispersion: 0.02,          // rainbowSplitz
      causticBr: 2.0,            // glowGlowBaby
      reflectivity: 0.8,         // mirrorMirror
      ambientIntensity: 0.2,     // softGlow
      hueCycle: 10,              // discoLight
      vignetteDark: 0.7          // tunnelVision
    };

    // ===== SCENE INITIALIZATION =====
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
    camera.position.set(0, 2, 5);
    camera.lookAt(0, 0, 0);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // ===== CONTROLS =====
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    // ===== LIGHTING =====
    scene.add(new THREE.AmbientLight(0xffffff, CONFIG.ambientIntensity));
    const point = new THREE.PointLight(0xffffff, 1);
    point.position.set(5, 5, 5);
    scene.add(point);

    // ===== LENS MATERIAL =====
    const lensMat = new THREE.MeshPhysicalMaterial({
      color: 0xffffff, metalness: 0, roughness: 0,
      transmission: 1, thickness: 0.5, ior: 1.5, transparent: true
    });

    // Create multiple lenses
    const lenses = [];
    [[1, [0,0,0]], [0.8, [-2,0,0]], [1.2, [2,0,0]], [0.5, [0,0,2.5]]].forEach(([s,pos]) => {
      const geo = new THREE.CylinderGeometry(1,1,0.2,64);
      const mesh = new THREE.Mesh(geo, lensMat.clone());
      mesh.scale.set(s, s, 1);
      mesh.rotation.x = Math.PI/2;
      mesh.position.set(...pos);
      scene.add(mesh);
      lenses.push(mesh);
    });
    // Prism
    const prmGeo = new THREE.CylinderGeometry(0.5,0.5,0.2,3);
    const prism = new THREE.Mesh(prmGeo, lensMat.clone());
    prism.rotation.x = Math.PI/2;
    prism.position.set(0,0,-2.5);
    scene.add(prism);
    lenses.push(prism);

    // ===== CAUSTICS PLANE =====
    const plGeo = new THREE.PlaneGeometry(10,10,64,64);
    const plMat = new THREE.ShaderMaterial({
      side: THREE.DoubleSide,
      uniforms: {
        lightPos: { value: point.position },
        time: { value: 0 },
        intensity: { value: CONFIG.causticBr },
        dispersion: { value: CONFIG.dispersion }
      },
      vertexShader: \`
        varying vec3 vPos;
        void main() {
          vPos = position;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      \`,
      fragmentShader: \`
        uniform vec3 lightPos;
        uniform float time, intensity, dispersion;
        varying vec3 vPos;
        void main() {
          float d = length(vPos.xz - lightPos.xz);
          float pr = sin((d - time*(1.0+dispersion))*10.0);
          float pg = sin((d - time)*10.0);
          float pb = sin((d - time*(1.0-dispersion))*10.0);
          float cr = smoothstep(0.0,1.0,pr)*intensity;
          float cg = smoothstep(0.0,1.0,pg)*intensity;
          float cb = smoothstep(0.0,1.0,pb)*intensity;
          gl_FragColor = vec4(cr, cg, cb, 1.0);
        }
      \`
    });
    const caustPlane = new THREE.Mesh(plGeo, plMat);
    caustPlane.rotation.x = Math.PI/2;
    scene.add(caustPlane);

    // ===== GROUND =====
    const grdGeo = new THREE.PlaneGeometry(10,10);
    const grdMat = new THREE.MeshPhysicalMaterial({
      color: 0x111111, metalness: 1, roughness: 0, reflectivity: CONFIG.reflectivity
    });
    const ground = new THREE.Mesh(grdGeo, grdMat);
    ground.rotation.x = -Math.PI/2;
    ground.position.y = -0.01;
    scene.add(ground);

    // ===== ANIMATION LOOP =====
    const clock = new THREE.Clock();
    function animate() {
      requestAnimationFrame(animate);
      const t = clock.getElapsedTime();
      lenses.forEach(l => l.rotation.z = t * CONFIG.rotationSpeed);
      plMat.uniforms.time.value = t;
      plMat.uniforms.intensity.value = CONFIG.causticBr;
      controls.update();
      renderer.render(scene, camera);
    }
    animate();

    // ===== HUE SHIFT =====
    anime({
      targets: point.color,
      r: [1,1,0.5],
      g: [1,0.5,1],
      b: [1,0.2,0.7],
      duration: CONFIG.hueCycle * 1000,
      easing: 'linear',
      loop: true
    });

    // ===== RESIZE =====
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth/ window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
