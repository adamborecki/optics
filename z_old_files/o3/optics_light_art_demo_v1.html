
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Optical Caustic Playground</title>
  <style>
    html, body { margin:0; height:100%; background:#000; overflow:hidden;}
    #opticsCanvas { display:block; width:100%; height:100%;}
    /* Vignette overlay */
    .vignette {
      position: fixed;
      pointer-events:none;
      inset:0;
      background: radial-gradient(circle at center, rgba(0,0,0,0) 60%, rgba(0,0,0,0.65) 100%);
    }
    /* Optional helper panel styles (toggle by uncommenting in JS) */
    #helperPanel{
      position:fixed;
      top:0; left:0;
      padding:0.5rem 0.75rem;
      font-family:monospace;
      font-size:0.85rem;
      background:rgba(0,0,0,0.5);
      color:#fff;
      border-bottom-right-radius:8px;
      user-select:none;
      pointer-events:none;
      line-height:1.2;
    }
  </style>
</head>
<body>
  <canvas id="opticsCanvas"></canvas>
  <div class="vignette"></div>
  <!-- (uncomment to show diagnostics)
  <pre id="helperPanel"></pre>
  -->
  <!-- Anime.js for smooth high‑level tweens -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js"></script>

  <!-- Everything else in an ES‑module -->
  <script type="module">

    /***********************************************************
     *  OPTICAL LIGHT‑ART PLAYGROUND
     *  — edit the CONFIG object below to sculpt the experience —
     *
     *  Naming convention:
     *   technicalVariableName   // «Fun Nickname»
     ***********************************************************/

    const CONFIG = {

      // ————— Scene tones —————
      /** Base gray for the void background (0‑1) — «VoidDarkness» */
      baseGray: 0.07,
      /** Overall scene exposure — «RetinaBurn»  */
      exposure: 1.0,

      // ————— Ring system —————
      /** Rotation speed for the primary optic ring (rad/sec) — «SaturnSlowDance» */
      ringRotationSpeed: 0.05,
      /** Thickness of the luminous ring (world units) — «HaloGirth» */
      ringThickness: 0.015,
      /** How far the rainbow channels are offset — «RainbowSpread» */
      dispersionStrength: 0.02,

      // ————— Caustic carpet —————
      /** Speed multiplier for caustic ripple animation — «Rippletastic» */
      causticRippleSpeed: 0.35,
      /** Intensity of caustic light (0‑1) — «LiquidLattice» */
      causticIntensity: 0.8,

      // ————— Post‑processing —————
      /** Bloom strength — «DivineGlow» */
      bloomStrength: 1.4,

      // ————— Chromatic drift —————
      /** Hue‑shift speed (cycles / sec) — «PrismaticWaltz» */
      hueShiftSpeed: 0.02,

      // ————— Camera choreography —————
      /** Duration of one camera orbit drift (ms) — «MeditativeOrbit» */
      cameraDriftDuration: 45000,
      /** Radius of the camera path around the scene center — «ZenDistance» */
      cameraOrbitRadius: 4,

      // ————— Lighting —————
      /** Spotlight tilt amplitude (deg) — «SunSwing» */
      lightTiltAmplitude: 12,
    };

    /* =========================================================
       END OF TWEAKABLES — dive in and play!
       ========================================================= */

    import * as THREE from 'https://unpkg.com/three@0.163.0/build/three.module.js';
    import { OrbitControls } from 'https://unpkg.com/three@0.163.0/examples/jsm/controls/OrbitControls.js';
    import { EffectComposer } from 'https://unpkg.com/three@0.163.0/examples/jsm/postprocessing/EffectComposer.js';
    import { RenderPass } from 'https://unpkg.com/three@0.163.0/examples/jsm/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'https://unpkg.com/three@0.163.0/examples/jsm/postprocessing/UnrealBloomPass.js';
    import { Reflector } from 'https://unpkg.com/three@0.163.0/examples/jsm/objects/Reflector.js';

    /* ---------- Basic Three.js setup ---------- */
    const canvas = document.getElementById('opticsCanvas');
    const renderer = new THREE.WebGLRenderer({canvas, antialias:true});
    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setClearColor(new THREE.Color(CONFIG.baseGray, CONFIG.baseGray, CONFIG.baseGray), 1);
    renderer.toneMappingExposure = CONFIG.exposure;

    const scene = new THREE.Scene();

    const camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 100);
    camera.position.set(0, 1.5, CONFIG.cameraOrbitRadius);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.enableZoom = false;
    controls.dampingFactor = 0.05;
    controls.autoRotate = false;

    /* ---------- Ring ensemble ---------- */
    const ringGroup = new THREE.Group();
    scene.add(ringGroup);

    const ringGeom = new THREE.TorusGeometry(1, CONFIG.ringThickness, 32, 256);

    const baseMatProps = {
      roughness: 0.05,
      metalness: 0.1,
      transmission: 1.0,
      ior: 1.4,
    };

    // white luminous core
    const coreMat = new THREE.MeshPhysicalMaterial({color: 0xffffff, ...baseMatProps});
    const coreRing = new THREE.Mesh(ringGeom, coreMat);
    coreRing.rotation.x = Math.PI/2;
    ringGroup.add(coreRing);

    // rainbow dispersion shells
    const colors = [0xff0000, 0x00ff00, 0x0000ff];
    const offsets = [-CONFIG.dispersionStrength, 0, CONFIG.dispersionStrength];

    offsets.forEach((off, idx)=>{
      if (off === 0) return; // skip middle (already made)
      const m = coreMat.clone();
      m.color = new THREE.Color(colors[idx]);
      const r = new THREE.Mesh(ringGeom, m);
      r.rotation.x = Math.PI/2;
      r.scale.setScalar(1 + off);
      ringGroup.add(r);
    });

    /* ---------- Reflective floor ---------- */
    const reflectorGeo = new THREE.PlaneGeometry(20,20);
    const reflector = new Reflector(reflectorGeo,{
      color: new THREE.Color(CONFIG.baseGray, CONFIG.baseGray, CONFIG.baseGray),
      textureWidth: window.innerWidth*window.devicePixelRatio,
      textureHeight: window.innerHeight*window.devicePixelRatio
    });
    reflector.rotation.x = -Math.PI/2;
    scene.add(reflector);

    /* ---------- Caustic shader plane ---------- */
    const causticUniforms = {
      u_time: {value:0},
      u_speed: {value:CONFIG.causticRippleSpeed},
      u_intensity: {value:CONFIG.causticIntensity}
    };

    const causticMat = new THREE.ShaderMaterial({
      transparent:true,
      uniforms: causticUniforms,
      vertexShader:`varying vec2 vUv;
        void main(){
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
        }`,
      fragmentShader:`varying vec2 vUv;
        uniform float u_time;
        uniform float u_speed;
        uniform float u_intensity;
        // very simple fake caustic via modulated sine patterns
        void main(){
          float t = u_time * u_speed;
          float wave = sin(20.0*(vUv.x+t))*sin(25.0*(vUv.y+t*0.8));
          float c = smoothstep(0.35,0.45,wave)*u_intensity;
          gl_FragColor = vec4(vec3(c), c);
        }`
    });

    const causticPlane = new THREE.Mesh(new THREE.PlaneGeometry(4,4), causticMat);
    causticPlane.rotation.x = -Math.PI/2;
    causticPlane.position.y = 0.01;
    scene.add(causticPlane);

    /* ---------- Lighting ---------- */
    const spot = new THREE.SpotLight(0xffffff, 3, 0, Math.PI/6, 0.5);
    spot.position.set(0, 3, 2);
    scene.add(spot);
    scene.add(spot.target);

    /* ---------- Post‑processing ---------- */
    const composer = new EffectComposer(renderer);
    composer.addPass(new RenderPass(scene, camera));
    const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), CONFIG.bloomStrength, 0.4, 0.85);
    composer.addPass(bloomPass);

    /* ---------- Anime.js camera drift ---------- */
    anime({
      targets: camera.position,
      x: CONFIG.cameraOrbitRadius * Math.sin(Math.PI / 6),
      z: CONFIG.cameraOrbitRadius * Math.cos(Math.PI / 6),
      duration: CONFIG.cameraDriftDuration,
      easing: 'easeInOutSine',
      direction: 'alternate',
      loop: true
    });

    /* ---------- Debug helper display ----------
    const helper = document.getElementById('helperPanel');
    */

    /* ---------- Render loop ---------- */
    const clock = new THREE.Clock();

    function render(){
      requestAnimationFrame(render);
      const delta = clock.getDelta();
      const elapsed = clock.elapsedTime;

      // main ring rotation
      ringGroup.rotation.z += CONFIG.ringRotationSpeed * delta;

      // subtle hue shift on dispersion rings
      ringGroup.children.forEach(mesh=>{
        let hsl = {};
        mesh.material.color.getHSL(hsl);
        hsl.h = (hsl.h + CONFIG.hueShiftSpeed*delta) % 1.0;
        mesh.material.color.setHSL(hsl.h, hsl.s, hsl.l);
      });

      // caustic time update
      causticUniforms.u_time.value = elapsed;

      // animate spotlight tilt
      spot.position.x = Math.sin(elapsed * 0.25) * 1.5;
      spot.position.z = 2 + Math.cos(elapsed * 0.18) * 1.5;

      controls.update();
      composer.render();

      /* if (helper){
        helper.textContent = 
          'fps: ' + Math.round(1/delta) + '\n' +
          'elapsed: ' + elapsed.toFixed(1);
      } */
    }
    render();

    /* ---------- Handle resizing ---------- */
    window.addEventListener('resize', ()=>{
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
      composer.setSize(window.innerWidth, window.innerHeight);
    });

  </script>
</body>
</html>
